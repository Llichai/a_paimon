# Paimon 项目代码注释规范

## 一、注释类型定义

### 1.1 JavaDoc注释（`/** */`）
用于**公共API文档**，已完全中文化

**应用范围**:
- 公开类、接口、枚举
- 公开方法和公开字段
- 已经在项目中全量实施

**格式规范**:
```java
/**
 * 功能简述
 *
 * <p>详细说明（如需要）
 *
 * <p>核心步骤或算法说明：
 * <ol>
 *   <li>步骤1说明
 *   <li>步骤2说明
 * </ol>
 *
 * <p>示例：
 * <pre>
 * // 代码示例
 * </pre>
 *
 * @param paramName 参数说明
 * @return 返回值说明
 * @throws ExceptionType 异常说明
 */
```

### 1.2 代码内注释（`//` 和 `/* */`）
用于**实现细节说明**，需要补充的重点区域

**类型分类**:
- **变量注释**: 说明变量用途（行内）
- **方法注释**: 说明方法步骤（前置块）
- **逻辑注释**: 说明复杂逻辑（嵌入式）
- **约束注释**: 说明特殊约束（行内或前置）

---

## 二、注释规范

### 2.1 成员变量注释规范

#### 规范1: 公开字段用JavaDoc
```java
/** 压缩单元列表，包含所有待压缩的文件 */
private List<CompactUnit> units;
```

#### 规范2: 私有字段用行内注释
```java
private final int[] tree;              // 败者树数组，存储比较结果
private final int size;                // 叶子节点数量
private final List<LeafIterator<T>> leaves;  // 叶子节点列表
private boolean ignoreDelete;          // 是否忽略删除记录
```

#### 规范3: 复杂类型添加详细说明
```java
/**
 * 映射关系：键为列名，值为列的统计信息
 * 支持schema演化，新增列的统计为null
 */
private Map<String, ColStats> colStats;
```

### 2.2 方法注释规范

#### 规范A: 简单方法（getter/setter）
```java
/**
 * 获取压缩单元
 * @return 压缩单元列表
 */
public List<CompactUnit> getUnits() {
    return units;
}
```

#### 规范B: 复杂算法方法
```java
/**
 * 通用压缩单元选择
 *
 * <p>选择触发条件的优先级：
 * <ol>
 *   <li>空间放大（Size Amplification）
 *   <li>大小比例（Size Ratio）
 *   <li>文件数量（Num Run Compaction Trigger）
 * </ol>
 *
 * <p>算法说明：
 * <pre>
 * 1. 从最小文件开始构建候选集合
 * 2. 逐个添加更大的文件到候选集合
 * 3. 检查大小比例条件：
 *    候选集合大小 * (100 + sizeRatio) / 100 < 下一个文件大小
 * 4. 如果条件满足，停止添加；否则继续
 * 5. 返回候选集合作为压缩单元
 * </pre>
 *
 * <p>示例：
 * <pre>
 * 文件大小：[10MB, 11MB, 50MB]
 * sizeRatio = 1
 *
 * 步骤1: 候选 = {10MB}
 * 步骤2: 10 * 1.01 = 10.1 < 11 → 加入 → {10MB, 11MB}
 * 步骤3: 21 * 1.01 = 21.21 < 50 → 加入 → {10MB, 11MB, 50MB}
 * </pre>
 *
 * @param maxLevel 最大压缩层级
 * @param runs 各层级的文件列表
 * @return 压缩单元，如果没有则返回空
 */
public Optional<CompactUnit> selectCompactUnit(
        int maxLevel, List<List<DataFileMetaProto>> runs) {
    // 实现代码...
}
```

#### 规范C: 状态机或流程方法
```java
/**
 * 调整败者树，更新胜者位置
 *
 * <p>调整流程：
 * <pre>
 * 1. 获取当前节点的两个子节点的胜者
 * 2. 比较两个胜者的键值
 * 3. 胜者继续向上传播
 * 4. 败者存储在当前节点
 * 5. 更新节点状态（NEW_KEY/SAME_KEY/POPPED）
 * </pre>
 *
 * <p>特殊优化：如果当前胜者被pop且有相同键，
 * 直接跳转到firstSameKeyIndex，避免逐层比较
 *
 * @param index 当前节点位置
 * @return 新的胜者
 */
private int siftDown(int index) {
    // 实现代码...
}
```

### 2.3 代码块注释规范

#### 规范a: 前置块注释（推荐）
```java
// 步骤1：尝试提前全量压缩
if (earlyFullCompact != null) {
    Optional<CompactUnit> unit = earlyFullCompact.tryFullCompact(numLevels, runs);
    if (unit.isPresent()) {
        return unit;
    }
}

// 步骤2：检查空间放大触发条件
// 公式：candidateSize * 100 > maxSizeAmp * earliestRunSize
CompactUnit unit = pickForSizeAmp(maxLevel, runs);
if (unit != null) {
    return Optional.of(unit);
}

// 步骤3：检查大小比例触发条件
unit = pickForSizeRatio(maxLevel, runs);
if (unit != null) {
    return Optional.of(unit);
}
```

#### 规范b: 行内逻辑注释
```java
// 清空最新记录，等待下一个键
latestKv = null;

// 忽略删除记录：DELETE和UPDATE_BEFORE类型
if (ignoreDelete && kv.valueKind().isRetract()) {
    return;
}

// 更新为最新记录
latestKv = kv;
```

#### 规范c: 特殊约束说明
```java
// 注意：对象复用问题
// 在返回一个键后，不能立即从RecordReader获取下一个键
// 必须等到所有RecordReader中的相同键都返回后，才能继续
// 否则对象可能在MergeFunction中被复用覆盖
while (hasNext()) {
    KeyValue kv = next();
    merge.add(kv);

    // 检查是否遇到新的键，如果遇到则停止
    if (isNewKey(kv)) {
        break;
    }
}
```

#### 规范d: 性能优化说明
```java
// 性能优化：使用败者树而不是最小堆
// 原因：在多路归并时，败者树的比较次数为O(log n)
// 而最小堆为O((k-1) * log n)，其中k为比较器数量
// 这里k通常较大，败者树性能优势明显
LoserTree<T> tree = new LoserTree<>(readers, comparator);
```

### 2.4 复杂数据结构说明

#### 规范I: 状态枚举
```java
/**
 * 节点状态枚举，用于败者树的快速调整
 *
 * <p>六种状态说明：
 * <ul>
 *   <li>LOSER_WITH_NEW_KEY：败者，包含新的键
 *   <li>LOSER_WITH_SAME_KEY：败者，键与全局胜者相同
 *   <li>LOSER_POPPED：败者，已经弹出
 *   <li>WINNER_WITH_NEW_KEY：胜者，包含新的键
 *   <li>WINNER_WITH_SAME_KEY：胜者，键与全局胜者相同
 *   <li>WINNER_POPPED：胜者，已经弹出
 * </ul>
 */
private enum NodeState {
    LOSER_WITH_NEW_KEY(false),
    LOSER_WITH_SAME_KEY(false),
    LOSER_POPPED(false),
    WINNER_WITH_NEW_KEY(true),
    WINNER_WITH_SAME_KEY(true),
    WINNER_POPPED(true);

    private final boolean isWinner;

    NodeState(boolean isWinner) {
        this.isWinner = isWinner;
    }
}
```

#### 规范II: 嵌套数据结构
```java
/**
 * 压缩单元，表示一次压缩的输入和输出
 *
 * <p>数据结构：
 * <ul>
 *   <li>inputs: 待压缩的文件列表（按大小递增排序）
 *   <li>outputLevel: 输出层级（必须 >= 最高输入层级）
 *   <li>parallelism: 压缩的并行度
 * </ul>
 */
private static class CompactUnit {
    private List<DataFileMeta> inputs;
    private int outputLevel;
    private int parallelism;
}
```

---

## 三、现有优秀示例

### 3.1 UniversalCompaction.java
- ✅ 完整的类级JavaDoc说明算法原理
- ✅ 成员变量都有中文注释
- ✅ 方法使用前置块注释说明流程
- ✅ 包含具体数值示例

### 3.2 LoserTree.java
- ✅ 详细说明了对象复用问题
- ✅ 状态机注释清晰
- ✅ 包含Wiki链接参考资料

### 3.3 DeduplicateMergeFunction.java
- ✅ 简洁的用途说明
- ✅ 性能特点明确
- ✅ 历史兼容性注释（中英双语）

---

## 四、注释覆盖检查表

| 项目 | 覆盖率 | 优先级 | 状态 |
|------|--------|--------|------|
| 公开类JavaDoc | 100% | 必须 | ✅ 已完成 |
| 公开方法JavaDoc | 100% | 必须 | ✅ 已完成 |
| 复杂算法内注释 | 待补充 | 高 | 🔄 进行中 |
| 关键变量注释 | 待补充 | 中 | 🔄 进行中 |
| 特殊约束说明 | 待补充 | 中 | 🔄 进行中 |
| 性能优化说明 | 待补充 | 低 | 📝 计划中 |

---

## 五、注释工具和辅助

### 5.1 IDE支持
- **IntelliJ IDEA**:
  - 快捷键 Alt+/ 生成JavaDoc
  - 搜索功能可找出缺少JavaDoc的方法

### 5.2 代码检查
- **Checkstyle**: 可配置检查JavaDoc覆盖率
- **SpotBugs**: 识别潜在的代码问题

### 5.3 文档生成
- **Maven Javadoc Plugin**: 生成HTML文档
- **PlantUML**: 生成架构图

---

## 六、常见注释错误

❌ **错误1：过度注释**
```java
// 错误的过度注释
i++;  // i增加1
```

✅ **正确方式**：代码自解释，无需注释

---

❌ **错误2：过时注释**
```java
// 错误：注释与代码不符
// 当前方法返回null
public String getName() {
    return "paimon";  // 实际返回非null
}
```

✅ **正确方式**：及时更新注释

---

❌ **错误3：不完整的算法说明**
```java
// 错误：没有说明算法原理
List<T> sort(List<T> data) {
    // 执行排序
}
```

✅ **正确方式**：说明算法选择原因
```java
/**
 * 使用败者树排序
 *
 * <p>原因：多路数据流，败者树性能最优
 */
List<T> sort(List<T> data) {
    // 实现
}
```

---

## 七、注释维护建议

1. **同步更新**: 修改代码时必须同时更新注释
2. **代码审查**: 审查时检查注释的准确性
3. **定期检查**: 定期检查过时或错误的注释
4. **示例更新**: 保持示例代码的可执行性
5. **链接检查**: 定期验证参考链接的有效性

---

*本规范基于Paimon项目的现有风格，旨在保持一致性和可读性*
